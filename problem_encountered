	//In merge sort
1.當資料量到達一千萬筆時，在merge時所產生的子陣列會使用太多的記憶體空間，8gm甚至不夠用，且在程式結束雖然有free，但在工作管理員顯示的記憶體使用量卻不會歸還
	->https://tmt514.github.io/algorithm-analysis/sorting/in-place-mergesort.html
	這篇文章介紹到把in-place algorithm加入倒merge sort裡面 (待研究)

2.在commit 8146bda65d549e0fe566159f203b1105e76ca62f 之前，我的merge sort 跑100萬筆資料都要3秒多。
	sol->用calloc, malloc... 等等的函式來要求記憶體會有效能問題,改成直接用陣列宣告, 花費的時間變成0.4秒左右。
		延伸思考->malloc 等函式是怎麼運行的?為什麼要花這麼多的時間?

3.如果把<stdio.h> #include 在main.c裡，在sorting.h裡就沒有辦法宣告FILE *fp 了
	
4. 第二次使用同一個sort 排序相同的型態十(int or char)會比第一次慢，但第二次之後的速度都差不多
	sor -> 找到會比較慢的原因了!
			因為我儲存資料的方法是，用指標陣列來儲存資料(both integer and string)
				然後把亂數資料先儲存到temp指標陣列裡每個指標所指向的地方
				每次要sorting前，把temp指標陣列所指向的值，複製到要被sorted的array(指標陣列)所指向的地方
				然而我的sorting是對array指標陣列裡所儲存的指標順序進行排序
				因此下一次複製時，array指標陣列的順序跟原先已經不一樣，只有其上的值會被蟲製成亂數

				現在改成用把temp的指標複製到array
				然後排序array指標的順序
